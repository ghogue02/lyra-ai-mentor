#!/usr/bin/env tsx\n\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { fileURLToPath } from 'url';\n\n// Production Deployment Verification Script\nclass DeploymentVerifier {\n  private readonly distPath: string;\n  private readonly srcPath: string;\n  private errors: string[] = [];\n  private warnings: string[] = [];\n\n  constructor() {\n    this.distPath = path.join(process.cwd(), 'dist');\n    this.srcPath = path.join(process.cwd(), 'src');\n  }\n\n  async runPreBuildChecks(): Promise<boolean> {\n    console.log('üîç Running pre-build verification checks...');\n    \n    try {\n      await this.verifyReactDependencies();\n      await this.validateSourceFiles();\n      await this.checkViteConfig();\n      \n      return this.reportResults('PRE-BUILD');\n    } catch (error) {\n      this.errors.push(`Pre-build verification failed: ${error}`);\n      return false;\n    }\n  }\n\n  async runPostBuildChecks(): Promise<boolean> {\n    console.log('üîç Running post-build verification checks...');\n    \n    try {\n      await this.verifyBuildOutput();\n      await this.validateReactChunks();\n      await this.checkBundleIntegrity();\n      await this.validateAssetHashing();\n      \n      return this.reportResults('POST-BUILD');\n    } catch (error) {\n      this.errors.push(`Post-build verification failed: ${error}`);\n      return false;\n    }\n  }\n\n  private async verifyReactDependencies(): Promise<void> {\n    console.log('  ‚úì Checking React dependencies...');\n    \n    const packageJsonPath = path.join(process.cwd(), 'package.json');\n    if (!fs.existsSync(packageJsonPath)) {\n      throw new Error('package.json not found');\n    }\n\n    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));\n    const dependencies = { ...packageJson.dependencies, ...packageJson.devDependencies };\n\n    // Critical React dependencies\n    const requiredDeps = {\n      'react': dependencies.react,\n      'react-dom': dependencies['react-dom'],\n      '@vitejs/plugin-react': dependencies['@vitejs/plugin-react'] || dependencies['@vitejs/plugin-react-swc']\n    };\n\n    for (const [dep, version] of Object.entries(requiredDeps)) {\n      if (!version) {\n        this.errors.push(`Missing critical dependency: ${dep}`);\n      } else {\n        console.log(`    ‚Ä¢ ${dep}: ${version}`);\n      }\n    }\n\n    // Check for version compatibility\n    if (dependencies.react && dependencies['react-dom']) {\n      const reactVersion = dependencies.react.replace(/[^0-9\\.]/g, '');\n      const reactDomVersion = dependencies['react-dom'].replace(/[^0-9\\.]/g, '');\n      \n      if (reactVersion !== reactDomVersion) {\n        this.warnings.push(`React version mismatch: react@${reactVersion} vs react-dom@${reactDomVersion}`);\n      }\n    }\n  }\n\n  private async validateSourceFiles(): Promise<void> {\n    console.log('  ‚úì Validating source files...');\n    \n    const mainTsxPath = path.join(this.srcPath, 'main.tsx');\n    if (!fs.existsSync(mainTsxPath)) {\n      this.errors.push('main.tsx not found');\n      return;\n    }\n\n    const mainContent = fs.readFileSync(mainTsxPath, 'utf8');\n    \n    // Check for React imports\n    if (!mainContent.includes('import React')) {\n      this.warnings.push('main.tsx should explicitly import React for production safety');\n    }\n\n    // Check for error handling\n    if (!mainContent.includes('try') || !mainContent.includes('catch')) {\n      this.warnings.push('main.tsx lacks error handling for production safety');\n    }\n\n    // Check for createRoot usage\n    if (!mainContent.includes('createRoot')) {\n      this.errors.push('main.tsx must use React 18+ createRoot API');\n    }\n  }\n\n  private async checkViteConfig(): Promise<void> {\n    console.log('  ‚úì Checking Vite configuration...');\n    \n    const viteConfigPath = path.join(process.cwd(), 'vite.config.ts');\n    if (!fs.existsSync(viteConfigPath)) {\n      this.errors.push('vite.config.ts not found');\n      return;\n    }\n\n    const viteConfig = fs.readFileSync(viteConfigPath, 'utf8');\n    \n    // Check for React plugin\n    if (!viteConfig.includes('@vitejs/plugin-react')) {\n      this.errors.push('Vite React plugin not configured');\n    }\n\n    // Check for React dedupe\n    if (!viteConfig.includes('dedupe') || !viteConfig.includes('react')) {\n      this.warnings.push('React dedupe not configured - may cause bundle issues');\n    }\n\n    // Check for manual chunks configuration\n    if (!viteConfig.includes('manualChunks')) {\n      this.warnings.push('Manual chunks not configured - bundle optimization missing');\n    }\n  }\n\n  private async verifyBuildOutput(): Promise<void> {\n    console.log('  ‚úì Verifying build output...');\n    \n    if (!fs.existsSync(this.distPath)) {\n      this.errors.push('dist directory not found');\n      return;\n    }\n\n    const files = fs.readdirSync(this.distPath);\n    \n    // Check for index.html\n    if (!files.includes('index.html')) {\n      this.errors.push('index.html not found in dist');\n    }\n\n    // Check for assets directory\n    const assetsPath = path.join(this.distPath, 'assets');\n    if (!fs.existsSync(assetsPath)) {\n      this.errors.push('assets directory not found in dist');\n    }\n  }\n\n  private async validateReactChunks(): Promise<void> {\n    console.log('  ‚úì Validating React chunks...');\n    \n    const assetsPath = path.join(this.distPath, 'assets');\n    if (!fs.existsSync(assetsPath)) {\n      return; // Already reported in verifyBuildOutput\n    }\n\n    const assetFiles = fs.readdirSync(assetsPath);\n    \n    // Look for React vendor chunk\n    const reactChunk = assetFiles.find(file => \n      file.includes('vendor-react') && file.endsWith('.js')\n    );\n\n    if (!reactChunk) {\n      this.warnings.push('vendor-react chunk not found - React may not be properly bundled');\n    } else {\n      console.log(`    ‚Ä¢ Found React chunk: ${reactChunk}`);\n      \n      // Verify React chunk size (should be substantial)\n      const chunkPath = path.join(assetsPath, reactChunk);\n      const stats = fs.statSync(chunkPath);\n      const sizeKB = Math.round(stats.size / 1024);\n      \n      console.log(`    ‚Ä¢ React chunk size: ${sizeKB}KB`);\n      \n      if (sizeKB < 100) {\n        this.warnings.push(`React chunk suspiciously small: ${sizeKB}KB`);\n      }\n    }\n  }\n\n  private async checkBundleIntegrity(): Promise<void> {\n    console.log('  ‚úì Checking bundle integrity...');\n    \n    const indexPath = path.join(this.distPath, 'index.html');\n    if (!fs.existsSync(indexPath)) {\n      return; // Already reported\n    }\n\n    const indexContent = fs.readFileSync(indexPath, 'utf8');\n    \n    // Check for script tags\n    const scriptMatches = indexContent.match(/<script[^>]*src=\"[^\"]*\"[^>]*>/g);\n    if (!scriptMatches || scriptMatches.length === 0) {\n      this.errors.push('No script tags found in index.html');\n    } else {\n      console.log(`    ‚Ä¢ Found ${scriptMatches.length} script tags`);\n      \n      // Verify all referenced files exist\n      for (const scriptTag of scriptMatches) {\n        const srcMatch = scriptTag.match(/src=\"([^\"]*)\"/); \n        if (srcMatch) {\n          const srcPath = srcMatch[1];\n          const fullPath = path.join(this.distPath, srcPath);\n          \n          if (!fs.existsSync(fullPath)) {\n            this.errors.push(`Referenced script not found: ${srcPath}`);\n          }\n        }\n      }\n    }\n  }\n\n  private async validateAssetHashing(): Promise<void> {\n    console.log('  ‚úì Validating asset hashing...');\n    \n    const assetsPath = path.join(this.distPath, 'assets');\n    if (!fs.existsSync(assetsPath)) {\n      return;\n    }\n\n    const assetFiles = fs.readdirSync(assetsPath);\n    \n    // Check for proper hash patterns\n    const hashPattern = /\\-[a-zA-Z0-9]{8,}\\./;\n    const hashedFiles = assetFiles.filter(file => hashPattern.test(file));\n    \n    console.log(`    ‚Ä¢ ${hashedFiles.length}/${assetFiles.length} files have content hashes`);\n    \n    if (hashedFiles.length === 0) {\n      this.warnings.push('No files have content hashes - cache invalidation may fail');\n    }\n\n    // Verify hash uniqueness\n    const hashes = hashedFiles.map(file => {\n      const match = file.match(/\\-([a-zA-Z0-9]{8,})\\./); \n      return match ? match[1] : null;\n    }).filter(Boolean);\n\n    const uniqueHashes = new Set(hashes);\n    if (hashes.length !== uniqueHashes.size) {\n      this.warnings.push('Duplicate content hashes detected');\n    }\n  }\n\n  private reportResults(phase: string): boolean {\n    console.log(`\\nüìä ${phase} VERIFICATION RESULTS:`);\n    \n    if (this.errors.length === 0 && this.warnings.length === 0) {\n      console.log('  ‚úÖ All checks passed successfully!');\n      return true;\n    }\n\n    if (this.errors.length > 0) {\n      console.log(`\\n‚ùå ERRORS (${this.errors.length}):`);\n      this.errors.forEach(error => console.log(`  ‚Ä¢ ${error}`));\n    }\n\n    if (this.warnings.length > 0) {\n      console.log(`\\n‚ö†Ô∏è  WARNINGS (${this.warnings.length}):`);\n      this.warnings.forEach(warning => console.log(`  ‚Ä¢ ${warning}`));\n    }\n\n    return this.errors.length === 0;\n  }\n}\n\n// Main execution\nasync function main() {\n  const verifier = new DeploymentVerifier();\n  const isPostBuild = process.argv.includes('--post-build') || fs.existsSync(path.join(process.cwd(), 'dist'));\n  \n  let success: boolean;\n  \n  if (isPostBuild) {\n    success = await verifier.runPostBuildChecks();\n  } else {\n    success = await verifier.runPreBuildChecks();\n  }\n\n  process.exit(success ? 0 : 1);\n}\n\nif (import.meta.url === `file://${process.argv[1]}`) {\n  main().catch(error => {\n    console.error('Verification script failed:', error);\n    process.exit(1);\n  });\n}\n