#!/usr/bin/env node

/**
 * MCP-Integrated Database Fix Automation
 * Uses Claude Flow MCP tools to coordinate database fixes
 */

import { execSync } from 'child_process';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Colors for output
const colors = {
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  reset: '\x1b[0m'
};

console.log(`${colors.cyan}🤖 MCP-Integrated Database Fix System${colors.reset}\n`);

// Step 1: Store current state in MCP memory
function storeStateInMemory(state) {
  try {
    execSync(`npx claude-flow hook notification --message "Database Fix State: ${JSON.stringify(state)}" --telemetry true`, {
      stdio: 'pipe'
    });
    console.log(`${colors.green}✓${colors.reset} Stored state in MCP memory\n`);
  } catch (error) {
    console.log(`${colors.yellow}⚠${colors.reset} Could not store in MCP memory\n`);
  }
}

// Step 2: Generate SQL fix file
function generateSQLFix() {
  console.log(`${colors.blue}📋 Generating SQL fix file...${colors.reset}`);
  
  const sqlContent = `-- Generated by MCP Database Fix System
-- Timestamp: ${new Date().toISOString()}

-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Drop existing tables if they exist (clean slate)
DROP TABLE IF EXISTS public.user_toolkit_achievements CASCADE;
DROP TABLE IF EXISTS public.user_toolkit_unlocks CASCADE;
DROP TABLE IF EXISTS public.toolkit_items CASCADE;
DROP TABLE IF EXISTS public.toolkit_achievements CASCADE;
DROP TABLE IF EXISTS public.toolkit_categories CASCADE;

-- Create toolkit_categories table
CREATE TABLE public.toolkit_categories (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    category_key TEXT UNIQUE NOT NULL,
    name TEXT NOT NULL,
    description TEXT NOT NULL,
    icon TEXT NOT NULL,
    gradient TEXT NOT NULL,
    order_index INTEGER NOT NULL DEFAULT 0,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Create toolkit_items table with metadata support
CREATE TABLE public.toolkit_items (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    name TEXT NOT NULL,
    category_id UUID NOT NULL REFERENCES public.toolkit_categories(id) ON DELETE CASCADE,
    description TEXT,
    preview_url TEXT,
    download_url TEXT,
    file_size INTEGER,
    file_type TEXT,
    is_new BOOLEAN DEFAULT FALSE,
    is_featured BOOLEAN DEFAULT FALSE,
    is_premium BOOLEAN DEFAULT FALSE,
    is_active BOOLEAN DEFAULT TRUE,
    required_level INTEGER DEFAULT 1,
    required_achievements TEXT[] DEFAULT '{}',
    download_count INTEGER DEFAULT 0,
    unlock_count INTEGER DEFAULT 0,
    rating_sum NUMERIC DEFAULT 0,
    rating_count INTEGER DEFAULT 0,
    average_rating NUMERIC GENERATED ALWAYS AS (
        CASE 
            WHEN rating_count > 0 THEN rating_sum / rating_count 
            ELSE 0 
        END
    ) STORED,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(category_id, name)
);

-- Create user_toolkit_unlocks table
CREATE TABLE public.user_toolkit_unlocks (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    toolkit_item_id UUID NOT NULL REFERENCES public.toolkit_items(id) ON DELETE CASCADE,
    unlocked_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    download_count INTEGER DEFAULT 0,
    last_downloaded_at TIMESTAMPTZ,
    rating INTEGER CHECK (rating >= 1 AND rating <= 5),
    rated_at TIMESTAMPTZ,
    user_notes TEXT,
    UNIQUE(user_id, toolkit_item_id)
);

-- Create toolkit_achievements table
CREATE TABLE public.toolkit_achievements (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    achievement_key TEXT UNIQUE NOT NULL,
    name TEXT NOT NULL,
    description TEXT NOT NULL,
    icon TEXT NOT NULL,
    color TEXT NOT NULL,
    criteria_type TEXT NOT NULL CHECK (criteria_type IN (
        'unlock_count', 'category_count', 'category_complete',
        'download_count', 'rating_count', 'streak_days', 'special'
    )),
    criteria_value INTEGER,
    criteria_metadata JSONB DEFAULT '{}',
    order_index INTEGER DEFAULT 0,
    achievement_tier TEXT CHECK (achievement_tier IN ('bronze', 'silver', 'gold', 'platinum')) DEFAULT 'bronze',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Create user_toolkit_achievements table
CREATE TABLE public.user_toolkit_achievements (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    achievement_id UUID NOT NULL REFERENCES public.toolkit_achievements(id) ON DELETE CASCADE,
    current_value INTEGER DEFAULT 0,
    target_value INTEGER,
    is_unlocked BOOLEAN DEFAULT FALSE,
    unlocked_at TIMESTAMPTZ,
    notification_shown BOOLEAN DEFAULT FALSE,
    UNIQUE(user_id, achievement_id)
);

-- Create indexes
CREATE INDEX idx_toolkit_items_category ON public.toolkit_items(category_id);
CREATE INDEX idx_toolkit_items_active ON public.toolkit_items(is_active) WHERE is_active = TRUE;
CREATE INDEX idx_user_toolkit_unlocks_user ON public.user_toolkit_unlocks(user_id);
CREATE INDEX idx_user_toolkit_unlocks_item ON public.user_toolkit_unlocks(toolkit_item_id);

-- Enable RLS
ALTER TABLE public.toolkit_categories ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.toolkit_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_toolkit_unlocks ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.toolkit_achievements ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_toolkit_achievements ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Anyone can view active categories"
    ON public.toolkit_categories FOR SELECT
    USING (is_active = TRUE);

CREATE POLICY "Anyone can view active toolkit items"
    ON public.toolkit_items FOR SELECT
    USING (is_active = TRUE);

CREATE POLICY "Users can view own unlocks"
    ON public.user_toolkit_unlocks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own unlocks"
    ON public.user_toolkit_unlocks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own unlocks"
    ON public.user_toolkit_unlocks FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Anyone can view achievements"
    ON public.toolkit_achievements FOR SELECT
    USING (TRUE);

CREATE POLICY "Users can view own achievement progress"
    ON public.user_toolkit_achievements FOR SELECT
    USING (auth.uid() = user_id);

-- Insert categories
INSERT INTO public.toolkit_categories (category_key, name, description, icon, gradient, order_index) VALUES
    ('email', 'Email Templates', 'Professional email templates for every occasion', 'Mail', 'from-blue-500 to-cyan-500', 1),
    ('grants', 'Grant Proposals', 'Winning grant proposal templates and guides', 'FileText', 'from-purple-500 to-pink-500', 2),
    ('data', 'Data Visualizations', 'Interactive charts and data presentation tools', 'BarChart3', 'from-green-500 to-emerald-500', 3),
    ('automation', 'Automation Workflows', 'Time-saving automation templates', 'Workflow', 'from-orange-500 to-red-500', 4),
    ('change', 'Change Management', 'Tools for managing organizational change', 'Users', 'from-indigo-500 to-purple-500', 5),
    ('social', 'Social Media Content', 'Engaging social media templates', 'Share2', 'from-pink-500 to-rose-500', 6),
    ('training', 'Training Materials', 'Educational resources and training templates', 'BookOpen', 'from-teal-500 to-cyan-500', 7),
    ('reports', 'Reports & Presentations', 'Professional report and presentation templates', 'Presentation', 'from-amber-500 to-orange-500', 8);

-- Insert achievements
INSERT INTO public.toolkit_achievements (achievement_key, name, description, icon, color, criteria_type, criteria_value, order_index, achievement_tier) VALUES
    ('first_unlock', 'First Tool Unlocked', 'Downloaded your first tool', 'Star', 'text-yellow-500', 'unlock_count', 1, 1, 'bronze'),
    ('category_explorer', 'Category Explorer', 'Unlock tools from 3 different categories', 'Grid3X3', 'text-blue-500', 'category_count', 3, 2, 'silver'),
    ('power_user', 'Power User', 'Unlock 10 tools', 'Zap', 'text-purple-500', 'unlock_count', 10, 3, 'gold');

-- Add sample PACE email item
INSERT INTO public.toolkit_items (name, category_id, description, file_type, is_new, is_active, metadata) 
SELECT 
    'PACE Email Template',
    id,
    'Professional email template using the PACE framework',
    'pace_email',
    true,
    true,
    '{"framework": "PACE", "version": "1.0"}'::jsonb
FROM public.toolkit_categories 
WHERE category_key = 'email';

-- Grant permissions
GRANT USAGE ON SCHEMA public TO anon, authenticated;
GRANT ALL ON ALL TABLES IN SCHEMA public TO anon, authenticated;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO anon, authenticated;

-- Final verification query
SELECT 
    'Toolkit setup complete!' as message,
    COUNT(DISTINCT tc.id) as categories_count,
    COUNT(DISTINCT ti.id) as items_count,
    COUNT(DISTINCT ta.id) as achievements_count
FROM public.toolkit_categories tc
LEFT JOIN public.toolkit_items ti ON tc.id = ti.category_id
CROSS JOIN public.toolkit_achievements ta;
`;

  const sqlPath = path.join(__dirname, 'mcp-toolkit-fix.sql');
  fs.writeFileSync(sqlPath, sqlContent);
  
  console.log(`${colors.green}✓${colors.reset} Generated SQL fix at: ${sqlPath}\n`);
  
  // Store in MCP memory
  storeStateInMemory({
    action: 'sql_generated',
    file: sqlPath,
    timestamp: new Date().toISOString()
  });
  
  return sqlPath;
}

// Step 3: Create automation script
function createAutomationScript(sqlPath) {
  console.log(`${colors.blue}📋 Creating automation script...${colors.reset}`);
  
  const scriptContent = `#!/bin/bash
# MCP Database Fix Automation Script
# Generated: ${new Date().toISOString()}

echo "🚀 MCP Database Fix Automation"
echo "=============================="
echo ""

# Check if running in CI/CD or local
if [ -n "$SUPABASE_DB_URL" ]; then
  echo "✓ Using SUPABASE_DB_URL from environment"
  DB_URL="$SUPABASE_DB_URL"
elif [ -n "$DATABASE_URL" ]; then
  echo "✓ Using DATABASE_URL from environment"
  DB_URL="$DATABASE_URL"
else
  echo "❌ No database URL found in environment"
  echo ""
  echo "📝 Manual steps required:"
  echo "1. Go to Supabase dashboard > Settings > Database"
  echo "2. Copy the connection string"
  echo "3. Run: export DATABASE_URL='your-connection-string'"
  echo "4. Re-run this script"
  echo ""
  echo "Alternatively, copy the SQL from: ${sqlPath}"
  echo "And run it in Supabase SQL Editor"
  exit 1
fi

# Apply the fix
echo "📦 Applying database fix..."
if command -v psql &> /dev/null; then
  psql "$DB_URL" -f "${sqlPath}" && echo "✓ Fix applied successfully!" || echo "❌ Fix failed"
else
  echo "❌ psql not found. Please install PostgreSQL client tools"
  echo "   On macOS: brew install postgresql"
  echo "   On Ubuntu: sudo apt-get install postgresql-client"
fi

# Notify MCP
npx claude-flow hook post-task --task-id "db-fix-applied" --analyze-performance true 2>/dev/null || true

echo ""
echo "🔍 Next step: Run verification"
echo "   node scripts/verify-toolkit-fix.js"
`;

  const scriptPath = path.join(__dirname, 'apply-mcp-fix.sh');
  fs.writeFileSync(scriptPath, scriptContent);
  fs.chmodSync(scriptPath, '755');
  
  console.log(`${colors.green}✓${colors.reset} Created automation script at: ${scriptPath}\n`);
  
  return scriptPath;
}

// Step 4: Create MCP workflow
function createMCPWorkflow() {
  console.log(`${colors.blue}📋 Creating MCP workflow configuration...${colors.reset}`);
  
  const workflow = {
    id: "db-fix-automation-v2",
    name: "Automated Database Fix v2",
    description: "Automatically fixes missing toolkit tables using multiple methods",
    triggers: [
      "404.*toolkit_categories",
      "relation.*does not exist",
      "Could not find.*category"
    ],
    steps: [
      {
        name: "detect_issue",
        action: "mcp__claude-flow__memory_usage",
        params: {
          action: "store",
          key: "db-fix/issue-detected",
          value: JSON.stringify({ timestamp: new Date().toISOString(), issue: "toolkit_tables_missing" })
        }
      },
      {
        name: "generate_fix",
        action: "terminal_execute",
        params: {
          command: "node scripts/mcp-db-fix.js"
        }
      },
      {
        name: "apply_fix",
        action: "terminal_execute", 
        params: {
          command: "./scripts/apply-mcp-fix.sh"
        },
        fallback: {
          action: "mcp__claude-flow__memory_usage",
          params: {
            action: "store",
            key: "db-fix/manual-required",
            value: JSON.stringify({ 
              message: "Automated fix failed. Manual intervention required.",
              sqlFile: "scripts/mcp-toolkit-fix.sql"
            })
          }
        }
      },
      {
        name: "verify_fix",
        action: "terminal_execute",
        params: {
          command: "node scripts/verify-toolkit-fix.js"
        }
      }
    ]
  };
  
  const workflowPath = path.join(__dirname, '..', '.claude', 'workflows', 'db-fix-automation-v2.json');
  fs.mkdirSync(path.dirname(workflowPath), { recursive: true });
  fs.writeFileSync(workflowPath, JSON.stringify(workflow, null, 2));
  
  console.log(`${colors.green}✓${colors.reset} Created MCP workflow at: ${workflowPath}\n`);
  
  return workflow;
}

// Main execution
async function main() {
  try {
    // Generate SQL fix
    const sqlPath = generateSQLFix();
    
    // Create automation script
    const scriptPath = createAutomationScript(sqlPath);
    
    // Create MCP workflow
    const workflow = createMCPWorkflow();
    
    // Summary
    console.log(`${colors.cyan}${'='.repeat(60)}${colors.reset}`);
    console.log(`${colors.cyan}Summary:${colors.reset}`);
    console.log(`${colors.cyan}${'='.repeat(60)}${colors.reset}\n`);
    
    console.log(`${colors.green}✅ MCP Database Fix System Ready!${colors.reset}\n`);
    
    console.log(`${colors.yellow}📁 Generated Files:${colors.reset}`);
    console.log(`   - SQL Fix: ${sqlPath}`);
    console.log(`   - Automation Script: ${scriptPath}`);
    console.log(`   - MCP Workflow: .claude/workflows/db-fix-automation-v2.json\n`);
    
    console.log(`${colors.yellow}🚀 Next Steps:${colors.reset}`);
    console.log(`   1. ${colors.blue}Automated:${colors.reset} ./scripts/apply-mcp-fix.sh`);
    console.log(`   2. ${colors.blue}Manual:${colors.reset} Copy SQL from ${sqlPath} to Supabase`);
    console.log(`   3. ${colors.blue}Verify:${colors.reset} node scripts/verify-toolkit-fix.js\n`);
    
    console.log(`${colors.yellow}🤖 MCP Integration:${colors.reset}`);
    console.log(`   The workflow will auto-trigger on toolkit errors`);
    console.log(`   Or manually: mcp__claude-flow__workflow_execute({ workflowId: "db-fix-automation-v2" })\n`);
    
    // Store completion in memory
    storeStateInMemory({
      action: 'system_ready',
      files: { sqlPath, scriptPath },
      workflow: workflow.id,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error(`${colors.red}❌ Error: ${error.message}${colors.reset}`);
    process.exit(1);
  }
}

// Run the automation
main();